---
layout: post
categories: 공부 책 cs
---

## chapter3 운영체제
### 3-1 운영체제의 큰 그림

운영체제는 컴퓨터 시스템의 중요한 부분으로, 하드웨어와 소프트웨어 자원을 관리하고 사용자와 시스템 간의 상호작용을 돕습니다. 운영체제는 다음과 같은 주요 역할을 합니다:

1. **자원 할당 및 관리**: 
   - **자원 관리**: CPU, 메모리, 저장 장치, 입출력 장치 등 다양한 하드웨어 자원을 효율적으로 관리합니다.
   - **파일 시스템 관리**: 데이터를 저장하고 검색하기 위한 파일 시스템을 제공합니다.

2. **프로세스 및 스레드 관리**: 
   - **프로세스 관리**: 여러 프로세스를 동시에 실행하고 관리하며, 프로세스 간의 자원 할당을 조정합니다.

3. **보안**: 시스템 자원과 데이터를 보호하기 위한 보안 메커니즘을 제공합니다.

4. **사용자 인터페이스**: 사용자와 시스템 간의 상호작용을 위한 인터페이스를 제공합니다.

#### 자원 할당 및 관리

자원(resource)이란 컴퓨터 프로그램이 실행되는 데 필요한 모든 요소를 의미합니다. 대표적으로 CPU, 메모리, 보조기억장치(디스크), 그리고 네트워크 자원 등이 있습니다. 운영체제는 이러한 자원들이 효율적으로 사용되도록 관리합니다.

- **CPU 관리:** CPU는 컴퓨터 시스템의 중앙 처리 장치로, 여러 프로그램이 동시에 실행될 수 있도록 스케줄링합니다.
- **메모리 관리:** 메모리는 실행 중인 프로그램과 데이터를 저장하는 공간입니다. 운영체제는 메모리를 효율적으로 관리하여 프로그램들이 원활하게 실행될 수 있도록 합니다.
- **파일 시스템 관리:** 파일 시스템은 데이터를 저장하고 검색하는 방법을 정의합니다. 운영체제는 파일 시스템을 통해 데이터를 체계적으로 관리합니다.

#### 프로세스 및 스레드 관리

프로세스(process)는 실행 중인 프로그램을 의미하며, 스레드(thread)는 프로세스 내에서 실행되는 작은 작업 단위입니다. 운영체제는 프로세스와 스레드의 생성, 스케줄링, 동기화, 그리고 종료를 관리합니다.

- **프로세스 관리:** 여러 프로세스가 동시에 실행될 수 있도록 스케줄링하고, 각 프로세스가 필요한 자원을 할당받을 수 있도록 관리합니다.
- **스레드 관리:** 한 프로세스 내에서 여러 스레드가 동시에 실행될 수 있도록 지원하며, 스레드 간의 동기화와 자원 공유를 관리합니다.

### 커널과 시스템 콜

운영체제의 핵심 부분은 **커널**(kernel)입니다. 커널은 자원 관리와 프로세스 관리를 담당하며, 하드웨어와 직접 상호작용합니다. 사용자는 **시스템 콜**(system call)을 통해 커널의 기능을 사용할 수 있습니다. 시스템 콜은 운영체제의 서비스를 요청하는 인터페이스로, 파일 읽기/쓰기, 프로세스 생성/종료, 메모리 할당/해제 등의 작업을 수행합니다.

### 시스템 콜과 이중 모드

운영체제는 사용자 프로그램과 하드웨어 간의 인터페이스를 제공하기 위해 시스템 콜을 사용합니다. 예를 들어, 파일을 읽거나 쓰는 작업, 프로세스를 생성하거나 종료하는 작업 등이 있습니다.

운영체제는 두 가지 모드로 운영됩니다:
1. **커널 모드**(Kernel Mode): 운영체제가 직접 하드웨어 자원에 접근할 수 있는 모드로, 시스템 콜을 처리하고 중요한 작업을 수행합니다.
2. **사용자 모드**(User Mode): 일반 애플리케이션이 실행되는 모드로, 직접 하드웨어 자원에 접근할 수 없으며 운영체제를 통해서만 접근할 수 있습니다.

이 두 가지 모드는 시스템의 안정성과 보안을 유지하기 위해 중요합니다. 사용자 모드에서 실행되는 프로그램이 직접 하드웨어에 접근할 수 없기 때문에, 잘못된 동작으로 인해 시스템 전체에 문제가 발생하지 않도록 합니다.

### 퀴즈

1. 운영체제의 주요 역할 중 하나가 아닌 것은 무엇인가요?
   1. 자원 관리
   2. 프로세스 관리
   3. 네트워크 관리
   4. 파일 시스템 관리

2. 시스템 콜은 무엇을 의미하나요?
   1. 운영체제가 사용자 프로그램의 요청을 처리하는 방법
   2. 하드웨어가 운영체제에 명령을 보내는 방법
   3. 사용자 프로그램이 직접 하드웨어 자원에 접근하는 방법
   4. 운영체제가 네트워크를 통해 다른 시스템과 통신하는 방법

3. 운영체제의 두 가지 모드 중, 일반 애플리케이션이 실행되는 모드는 무엇인가요?
   1. 커널 모드
   2. 사용자 모드
   3. 관리자 모드
   4. 디바이스 모드

4. 사용자 모드에서 실행되는 프로그램이 하드웨어 자원에 접근할 수 있는 방법은 무엇인가요?
   1. 직접 접근
   2. 시스템 콜을 통해 접근
   3. 운영체제의 허락 없이 접근 
   4. 하드웨어 모드에서 접근

<details>
   <summary>답</summary>

   3, 1, 2, 2
</details>

--- 

### 3-2 프로세스와 스레드 

#### 프로세스
- **정의**: 실행 중인 프로그램.
- **구성 요소**: 코드, 데이터, 힙, 스택.
  - **코드**: 실행 가능한 명령어가 저장된 공간. 읽기 전용. 
  - **데이터**: 초기화된 전역 변수와 정적 변수가 저장된 공간. 정적 할당 영역. 
  - **힙**: 동적으로 할당된 메모리가 저장되는 공간.
  - **스택**: 함수 호출과 관련된 지역 변수와 매개 변수가 저장되는 공간.

#### 스레드
- **정의**: 프로세스 내에서 실행의 단위.
- **구성 요소**: 스레드 ID, 프로그램 카운터, 레지스터, 스택.
  - **스레드 ID**: 스레드를 식별하는 고유 정보.
  - **프로그램 카운터**: 다음 실행 명령어 주소를 저장.
  - **레지스터**: 연산 과정에서 사용되는 임시 저장 공간.
  - **스택**: 함수 호출 관련 데이터를 저장.

#### 프로세스 제어 블록(PCB)
- **정의**: PCB는 프로세스의 상태, CPU 레지스터, 메모리 정보 등을 저장하여 운영체제가 프로세스를 관리하고 문맥 교환 시 필요한 정보를 제공합니다.

#### PCB 역할
- **문맥 교환(Context Switching)**: CPU가 다른 프로세스로 전환될 때 현재 프로세스의 상태를 PCB에 저장하고, 다음 프로세스의 상태를 PCB에서 복원.

#### 멀티프로세스와 멀티스레드
- **멀티프로세스**: 여러 프로세스를 동시에 실행하는 방식. 독립된 메모리 공간 사용.
- **멀티스레드**: 하나의 프로세스 내에서 여러 스레드를 동시에 실행하는 방식. 동일한 메모리 공간 공유.

#### 주요 차이점
- **자원 공유**: 멀티프로세스는 자원 공유 안함, 멀티스레드는 자원 공유.
- **오류 영향 범위**: 멀티프로세스는 오류 영향 없음, 멀티스레드는 오류가 전체에 영향.

#### 원격 프로시저 호출(RPC)
- **정의**: RPC는 원격 코드를 실행하는 기술로, 한 프로세스에서 다른 프로세스의 코드를 실행하는 방식입니다.
- **기능**: 
  - **성능 저하 최소화**: RPC는 프로그래밍 언어나 플랫폼에 무관하게 성능 저하를 최소화하며 메시지 송수신이 가능합니다.
  - **대규모 트래픽 처리**: 특히 서버 간 통신 환경에서 자주 사용됩니다.

#### RPC의 특징
- **프로세스 간 통신(IPC)**: RPC는 네트워크 소켓을 통해 IPC를 수행할 수 있습니다.
- **메시지 전달**: 프로세스 간에 주고받는 데이터가 커널을 거쳐 송수신됩니다. 이는 공유 메모리 기반 IPC보다 상대적으로 레이스 컨디션이나 동기화 문제를 덜 고려하게 합니다.
- **구현 프레임워크**: 오늘날 가장 대중적으로 사용되는 RPC 프레임워크는 구글의 gRPC입니다.

### 문제

1. **프로세스와 스레드의 차이점을 설명하시오.**
   <details>
      <summary>답</summary>

       프로세스는 실행 중인 프로그램으로 독립적인 메모리 공간을 가지며, 스레드는 프로세스 내에서 실행의 단위로 동일한 메모리 공간을 공유합니다.
   </details>

2. **멀티프로세스와 멀티스레드의 주요 차이점을 설명하시오.**
   <details>
      <summary>답</summary>
      
      멀티프로세스는 독립적인 메모리 공간을 사용하여 자원을 공유하지 않지만, 멀티스레드는 동일한 주소 공간을 공유하여 자원을 공유합니다. 또한, 멀티프로세스는 한 프로세스의 오류가 다른 프로세스에 영향을 주지 않지만, 멀티스레드는 한 스레드의 오류가 전체 프로세스에 영향을 줄 수 있습니다.
   </details>

### 3-3 동기화와 교착 상태 

#### 동기화
- **정의**: 다수의 프로세스나 스레드가 공유 자원에 동시에 접근할 때 일관된 결과를 보장하기 위한 기법.
- **공유 자원**: 메모리, 파일, 전역 변수, 입출력 장치 등.
- **임계 구역**: 동시에 접근하면 문제가 발생할 수 있는 공유 자원의 코드 부분.
- **문제 해결 방법**: 상호 배제, 잠금 메커니즘 등을 사용해 동기화를 구현.

#### 교착 상태(Deadlock)
- **정의**: 두 개 이상의 프로세스가 서로 자원을 기다리며 무한정 대기하는 상태.
- **발생 조건**:
  1. **상호 배제**: 자원이 한 번에 하나의 프로세스만 접근 가능.
  2. **점유와 대기**: 자원을 점유한 상태에서 다른 자원을 기다림.
  3. **비선점**: 다른 프로세스의 자원을 강제로 빼앗을 수 없음.
  4. **원형 대기**: 프로세스들이 원형으로 자원을 기다림.
  
#### 교착 상태 해결 방법
1. **교착 상태 예방**: 4가지 조건 중 하나를 만족하지 않도록 설계.
   - **예시**: 자원에 번호를 매기고 오름차순으로만 자원을 할당.
2. **교착 상태 회피**: 자원 할당 시 교착 상태가 발생하지 않도록 조심.
   - **예시**: 은행원 알고리즘.
3. **교착 상태 검출 및 회복**: 교착 상태를 주기적으로 검출하고 회복.
   - **회복 방법**: 자원 선점, 교착 상태 프로세스 강제 종료.

### 문제

1. **동기화란 무엇이며, 왜 필요한가요?**
   <details>
      <summary>답</summary>

      동기화는 다수의 프로세스나 스레드가 공유 자원에 접근할 때 일관된 결과를 보장하기 위한 기법으로, 임계 구역의 문제를 해결하기 위해 필요합니다.
   </details>

2. **교착 상태의 네 가지 발생 조건은 무엇인가요.**
   <details>
   <summary>답</summary>
   
   교착 상태는 상호 배제, 점유와 대기, 비선점, 원형 대기 조건이 모두 만족될 때 발생합니다. 각각은 자원의 독점적 사용, 자원 대기, 자원의 강제 획득 불가, 순환적 자원 대기를 의미합니다.
   </details>
   

### 3-4 CPU 스케줄링 
### 선점형 vs 비선점형 스케줄링

CPU 스케줄링에서 프로세스에 CPU를 할당하는 방식은 **선점형(preemptive)**과 **비선점형(non-preemptive)**으로 나뉩니다. 이 두 가지 방식은 프로세스의 실행 중에 CPU를 어떻게 제어하고, 할당하는지에 대한 차이를 말합니다.

#### 1. **선점형 스케줄링 (Preemptive Scheduling)**

**개념**:  
선점형 스케줄링에서는 CPU를 사용하던 프로세스가 강제로 중단되고, 다른 프로세스가 CPU를 할당받을 수 있습니다. 즉, 운영체제가 더 중요한(우선순위가 높거나) 작업을 처리하기 위해 현재 실행 중인 프로세스를 중단시키고 다른 프로세스에게 CPU를 배정하는 방식입니다.

**장점**:
- **반응성**: 실시간으로 빠르게 처리해야 하는 작업에 적합합니다.
- **시스템 효율성 향상**: 우선순위가 높은 프로세스가 빠르게 CPU를 사용할 수 있어 전체 성능을 개선할 수 있습니다.
  
**단점**:
- **문맥 교환 오버헤드**: 프로세스가 중단되고 새로운 프로세스를 처리하기 위해 문맥 교환(context switch)이 자주 발생하면 CPU 자원을 소모하게 됩니다.
  
**사용 사례**:
- **실시간 시스템**: 사용자의 즉각적인 반응이 중요한 환경, 예를 들어 항공 관제 시스템, 온라인 게임, 운영체제의 핵심 작업 스케줄링 등에 사용됩니다.
  
**알고리즘**:
- **라운드 로빈 스케줄링**: 정해진 시간만큼 실행 후 다음 프로세스로 교체됩니다.
- **최소 잔여 시간 우선 스케줄링**: 가장 짧은 남은 시간을 가진 프로세스가 우선 처리됩니다.
- **우선순위 기반 스케줄링**: 우선순위가 높은 프로세스가 CPU를 할당받습니다.

---

#### 2. **비선점형 스케줄링 (Non-Preemptive Scheduling)**

**개념**:  
비선점형 스케줄링에서는 프로세스가 자발적으로 종료하거나, 입출력(I/O) 작업을 시작할 때까지 CPU를 독점적으로 사용합니다. 다른 프로세스가 CPU를 할당받기 위해서는 현재 실행 중인 프로세스가 CPU를 반환해야만 합니다.

**장점**:
- **문맥 교환이 적음**: 한 프로세스가 끝날 때까지 CPU를 독점하기 때문에 불필요한 문맥 교환이 발생하지 않으며, 오버헤드가 줄어듭니다.
  
**단점**:
- **응답 시간이 느림**: 우선순위가 낮거나 CPU를 오랫동안 점유하는 프로세스가 있을 경우, 다른 중요한 프로세스가 오랜 시간 대기해야 할 수 있습니다.
  
**사용 사례**:
- **일괄 처리 시스템**: 일괄적으로 작업을 처리하는 배치 시스템에서 사용됩니다. 예를 들어, 컴파일러 작업이나 대규모 데이터 처리 시스템에서 자주 사용됩니다.
  
**알고리즘**:
- **선입 선처리 스케줄링 (FCFS)**: 준비된 순서대로 처리합니다.
- **최단 작업 우선 스케줄링 (SJF)**: 가장 짧은 작업을 먼저 처리합니다.

---

### **차이점 요약**

|  | **선점형 스케줄링** | **비선점형 스케줄링** |
| --- | --- | --- |
| **프로세스 중단 여부** | 실행 중인 프로세스를 강제로 중단하고 다른 프로세스에 CPU를 할당할 수 있음 | 프로세스가 끝날 때까지 CPU를 계속 사용 |
| **오버헤드** | 문맥 교환에 따른 오버헤드 발생 | 문맥 교환이 적어 오버헤드가 적음 |
| **응답성** | 응답성이 빠름, 실시간 시스템에 적합 | 응답 시간이 느림 |
| **사용 사례** | 실시간 시스템, 멀티태스킹 운영체제 | 배치 처리 시스템, 일괄 처리 작업 |

---

### **실제 활용 예시**
- **선점형 스케줄링**: 스마트폰 운영체제의 앱 전환, 실시간 시스템(항공 관제 시스템, 네트워크 서버) 등에서 중요한 작업을 우선적으로 처리할 때 선점형 스케줄링이 사용됩니다.
  
- **비선점형 스케줄링**: 데이터베이스 관리 시스템(DBMS)에서 대용량 데이터를 처리하는 작업에 비선점형 스케줄링이 주로 사용됩니다. 컴파일러 작업이나 배치 처리가 많은 환경에서 CPU 자원을 독점적으로 사용해 작업을 완료하는 데 적합합니다.

이 두 방식은 각각의 장단점이 있기 때문에, 시스템의 요구사항에 따라 선택적으로 사용됩니다. 예를 들어, 실시간 응답이 중요한 환경에서는 선점형 스케줄링을, 대규모 배치 작업이 필요한 환경에서는 비선점형 스케줄링을 주로 활용합니다.

---

### 문제 
Q. 선점형 스케줄링과 비선점형 스케줄링의 차이점은 무엇인가요?

### 3-4 가상 메모리

가상 메모리는 **물리적 메모리보다 큰 프로그램을 실행할 수 있게 하는 메모리 관리 기법**입니다. 실행하고자 하는 프로그램의 일부만 실제 메모리에 적재하고 나머지는 **보조기억장치**를 사용하여, 시스템이 실제 메모리 용량보다 더 많은 프로그램을 동시에 실행할 수 있도록 해줍니다.

#### 1. **논리 주소와 물리 주소**
- CPU와 프로세스는 직접적으로 물리적 메모리 주소를 참조하지 않습니다. 대신 **논리 주소**를 사용하며, 운영체제는 이 논리 주소를 실제 물리 주소로 변환하는 역할을 합니다.
- 가상 메모리 기법을 사용하여 프로세스가 요구하는 메모리 공간과 실제 메모리 공간 사이에 논리적 변환을 적용합니다 .

#### 2. **페이징 (Paging)**
- 페이징은 가상 메모리에서 **외부 단편화** 문제를 해결하는 기법입니다.
- 프로세스의 주소 공간을 일정한 크기의 **페이지**로 나누고, 물리적 메모리 공간을 같은 크기의 **프레임**으로 나눈 후, 페이지를 프레임에 할당하는 방식입니다. 이로 인해 프로세스는 **불연속적**으로 물리 메모리에 저장될 수 있어 메모리 공간의 낭비를 최소화합니다  .

#### 3. **세그멘테이션 (Segmentation)**
- 세그멘테이션은 프로세스를 **가변적인 크기의 세그먼트**로 나누어 관리하는 방식입니다. 세그먼트는 논리적인 의미를 가지는 단위(예: 코드, 데이터 등)로 나뉘며, 각 세그먼트는 크기가 다를 수 있습니다.
- 세그멘테이션 방식은 **외부 단편화** 문제를 야기할 수 있으나, 논리적으로 더 유의미한 단위로 메모리를 관리할 수 있다는 장점이 있습니다 .

### 문제

Q. **가상 메모리가 필요한 이유는 무엇인가요?**

---


### 3-6 파일 시스템

**파일 시스템**은 보조기억장치에 저장된 데이터를 **파일과 디렉터리** 구조로 관리하는 운영체제의 중요한 기능입니다. 파일 시스템을 통해 운영체제는 보조기억장치에서 데이터를 효율적으로 읽고, 쓰고, 삭제하는 작업을 수행합니다.

####  **파일 시스템 구조**
- **슈퍼블록**: 파일 시스템의 전체적인 정보를 담고 있는 영역으로, 파일 시스템의 크기, 사용 가능한 블록 수 등을 관리합니다.
- **아이노드(Inode)**: 파일과 디렉터리의 정보를 저장하는 구조체로, 파일의 속성, 위치 정보 등을 포함합니다.
- **데이터 블록**: 실제 파일 데이터가 저장되는 블록입니다. 운영체제는 각 파일이 여러 블록에 분산 저장되도록 하여 효율적인 데이터 관리를 수행합니다.

#### **파일 할당 기법**
- **연속 할당(Contiguous Allocation)**: 파일을 연속된 블록에 저장하는 방식으로, 빠른 접근 속도를 자랑하지만 외부 단편화 문제가 발생할 수 있습니다.
- **연결 할당(Linked Allocation)**: 파일을 연결 리스트 형태로 블록에 할당하는 방식으로, 단편화를 줄이지만 접근 속도가 느립니다.
- **색인 할당(Indexed Allocation)**: 파일의 모든 블록의 주소를 색인 블록에 기록하여 관리하는 방식입니다. 색인 블록만으로 파일의 모든 데이터에 접근이 가능합니다.

#### **파일 시스템의 종류**
- **NTFS (New Technology File System)**: 윈도우에서 주로 사용되는 파일 시스템으로, 보안과 복구 기능이 뛰어납니다.
- **EXT (Extended File System)**: 리눅스에서 사용되는 파일 시스템으로, EXT2, EXT3, EXT4 등의 버전이 있으며, 성능과 안정성을 향상시킨 다양한 기능을 제공합니다.
- **APFS (Apple File System)**: 애플의 macOS에서 사용되는 파일 시스템으로, 데이터 무결성 및 효율적인 스토리지 관리를 지원합니다

### 문제

Q. **파일 시스템에서 '아이노드'가 하는 역할은 무엇인가요?**

<details>
<summary> 답 </summary>

**아이노드(Inode)**는 파일 시스템에서 파일이나 디렉터리의 메타데이터를 저장하는 데이터 구조체입니다. 아이노드에는 파일의 실제 데이터는 포함되지 않으며, 파일의 속성과 위치 정보를 관리하여 운영체제가 해당 파일을 효율적으로 처리할 수 있도록 합니다.

</details>

Q. **연속 할당 방식의 장단점은 무엇인가요?**

<details>
<summary> 답 </summary>

장점:
- 빠른 접근 속도: 파일이 연속된 블록에 저장되므로, 파일을 읽을 때 디스크 헤드의 이동이 최소화되어 빠르게 접근할 수 있습니다.
- 단순성: 파일의 첫 번째 블록의 주소와 파일의 크기만 알고 있으면, 파일의 모든 블록에 바로 접근할 수 있습니다.

단점:

- 외부 단편화: 연속된 빈 블록을 찾기가 어려워지면, 파일을 저장할 수 있는 공간이 부족해지는 외부 단편화 문제가 발생할 수 있습니다.
- 파일 크기 변경의 어려움: 파일 크기가 증가하거나 감소할 경우, 중간에 빈 블록이 없다면 연속된 공간으로 파일을 다시 저장해야 하므로 비효율적일 수 있습니다.

</details>

---

## chapter 4 자료구조 


#### **빅 오 표기법** 
함수의 점근적 상한을 표기하는 방법. 
   - 실행 시간이 대략 이 이상은 커지지 않을 것이라는 의미.
   - 입력에 따라 필요한 메모리 자원의 양에 대한 점근적 상한 
   - 알고리즘의 성능 판단에 사용되는 척도는 주로 시간 복잡도가 많기 때문에 빅 오 표기법으로 표현된 성능은 시간 복잡도로 봐도 됌.

#### 배열

일정한 **메모리 공간**을 차지하는 여러 요소들이 **순차적**으로 나열된 자료구조 

#### 연결 리스트 
노드의 모음으로 구성된 자료구조. 연속적으로 구성되어 있는 데이터를 불연속적으로 저장할 때 유용. 
중간 요소 추가나 삭제 연산에 유리. 
- 노드 : 저장하고자 하는 데이터와 다음 노드의 위치(메모리 주소) 정보를 포함한 구성 단위 

#### 스택 
한 쪽에서만 데이터 삽입(push) 및 삭제(pop). 후입선출 자료구조 
- 최근에 임시 저장한 데이터를 가장 먼저 활용해야 할 때 
   - 함수의 매개변수 저장
   - 뒤로가기 기능을 만들고 싶을 때 

#### 큐 
한 쪽으로 데이터 삽입(enqueue), 다른 한 쪽으로 데이터 삭제(dequeue). 선입선출 자료구조.
- 줄세우기 : 임시 저장된 데이터를 순서대로 처리해야하는 일 **버퍼**
- 우선순위 큐 : 우선순위로 처리되는 큐 -> 힙 기반

#### 해시 테이블
키와 값 대응으로 이루어진 표같은 자료구조. 키를 통해 얻을 데이터는 버킷에 저장. 
빠른 검색 속도를 보장. 단, 메모리 공간을 많이 사용함. 해시 충돌도 일어남
- 사용예 : 페이지 캐시, 네트워크, 데이터베이스 

##### 해시 충돌
서로 다른 키에 대해 같은 해시 값이 대응되는 상황 
- 해결 방법 
   - 체이닝: 충돌 발생한 데이터를 연결 리스트로 추가 
      - 빠른 속도 장점을 못 살릴 수 있음
   - 개방 주소법: 충돌 발생 시 다른 인덱스에 데이터 저장 
      - 선형 조사법: 가능한 인덱스를 찾아 1씩 늘림 -> 데이터 군집화 발생
      - 이차 조사법: 가능한 인덱스를 찾아 제곱씩 늘림 -> 임시 방편일 뿐
   - 이중 해싱: 충돌 발생시, 다른 해시 함수에 대한 해시 인덱스를 더하여 인덱스를 찾음

#### 트리 
계층적인 구조. 노드, 간선(링크)로 이루어짐. 간선으로 연결된 노드는 상하 관계를 형성. 
- 차수: 각 노드가 가지는 자식 노드 수 
- 레벨: 특정 노드가 얼마나 깊은 지 

##### 트리 순회 
모든 노드를 한번씩 방문하는 것. 
- 전위 순회 : 루트 노드부터 왼족 서브트리 전휘 순회하고 오른쪽 서브트리 전위 순회 
- 중위 순회 : 루트 기준 왼쪽 서브트리를 중위 순회, 루트 노드 방문하고 오른쪽 서브트리 중위 순회 
- 후위 순회 : 루트 기준 외쪽 서브트리부터 후위, 오른쪽 서브트리 후위 

##### 이진 탐색 트리
특정 노드의 왼쪽 서브트리에는 해당 노드보다 작은 값을 지닌 노드, 오르쪽엔 큰 노드 
- 힙: 완전 이진 트리. 최댓값과 최솟값을 빠르게 찾기 위해 사용. 
   - 시간복잡도: logn

#### 균형: RB 트리 (Red-Black)
왼쪽 서브트리와 오른쪽 서브트리 높이의 균형을 맞추는 이진 탐색 트리
- 사용예시 
   - CFS 스케줄러 : 리눅스 CPU 스케줄러 
   - C++ 해시테이블 
- 유지 조건
   - 루트 노드는 블랙
   - 리프 노드는 블랙
   - 레드 노드 자식은 블랙
   - 루트 노드에서 임의의 리프 노드에 이르는 경로의 블랙 노드 수는 같다
   - 리프 노드는 실질적 데이터가 저장되어 있지 않은 노드 
- 새 노드 삽입시 삽입할 노드를 레드로 간주 
   - RB트리 조건에 맞지 않으면 트리를 회전하거나 색상을 재지정
      - 트리 회전: 부모 노드, 자식 노드 관계 재지정

#### 대용량 입출력 : B 트리
다진 탐색 트리. 한 노드가 여러 자식 노드를 가질 수 있음. 최소 자식 노드의 개수는 M/2개. 하나 이상의 키 값이 존재. 각 키들은 오름차순으로 저장됨. 키가 N개인 노드가 가질 수 있는 자식 노드의 수는 반드시 N+1ro. B트리는 모든 리프 노드의 깊이가 같음. 


#### 그래프
정점이라 불리는 데이터를 간선 혹은 링크ㅗ 연결한 형태 자료구조. 트리도 그래프의 일종. 데이터 간의 연결 관계를 표현하는 자료구조. 

#### 깊이 우선 탐색(DFS) 너비 우선 탐색(BFS)
- 깊이 우선 탐색: 더 이상 방문 가능한 정점이 없을 떄까지 최대한 깊이 탐색을 반복
   - 스택 사용
- 너비 우선 탐색: 최대한 넓게 탐색 반복. 인접한 모든 정점들을 방문. 
   - 큐 사용

### 문제 
Q. 해시 충돌이 무엇이며, 어떻게 해시 충돌을 해결할 수 있나요? 
Q. RB 트리란 무엇인가요? 
Q. B 트리란 무엇인가요? 

***

## chapter 5 네트워크 
### 1 네트워크의 큰 그림 

네트워크 기기 (노드)와 네트워크 기기 간 정보를 주고받는 유무선의 통신 매체(간선)로 이루어진 그래프 형태. 

네트워트 상 노드와 노드 사이 연결 구조를 **네트워크 토폴로지**라 부름. 

네트워크 구성 요소
- 호스트(host): 정보 송신 및 수신 장치 (예: 노트북, 서버).
  - 클라이언트(client): 요청을 보내는 호스트.
  - 서버(server): 응답을 보내는 호스트.
- 중간 노드: 정보 전송을 돕는 네트워크 장비 (예: 스위치, 라우터, 공유기).

패킷: 네트워크를 통해 송수신되는 데이터의 단위
   - 페이로드 : 송수신하고자 하는 데이터 
   - 헤더 : 패킷에 추가되는 부가 정보 
      - 주소 (IP주소, MAC주소)
   - 트레일러 : 패킷에 추가되는 부가 정보 

네트워크 전송 방식 
 - 유니캐스트 :일대일 
 - 브로드캐스트 : 모든 호스트 
 - 멀티 캐스트 : 동일 그룹 
 - 애니 캐스트 : 동일 그룹 중 가장 가까운 호스트 

프로토콜: 네트워크에서 통신을 주고받는 노드 간의 합의된 규칙이나 방법 
- IP : 네트워크 간의 주소를 지정 
- ARP : IP주소와 MAC 주소 대응 
- TCP 
- UDP 

#### 문제 
Q. 패킷과 프로토콜에 대해서 설명하세요 

### 2 물리 계층과 데이터 링크 계층 

이더넷 : 통신 매체를 통해 신호를 송수신하는 방법, 데이터 링크 계층에서 주고받는 데이터 형식 등이 정의된 기술

이더넷 프레인: 이더넷 기반의 네트워크에서 주고받는 프레임 
- 프리앰블 : 송수신지 동기화를 위해 사용되는 8바이트 정보. 현재의 이더넷 프레임이 수신되고 있다는 사실을 앎
- 송수신지 MAC 주소 : 가장 중요한 ㅈ어보 
- 타입/ 길이 
- 데이터 : 페이로드. 데이터의 최대 크기가 정해져있음 
- FCS : 트레일러. 프레임의 오류가 있는지의 여부를 확인하기 위한 필드. CRC라는 오류 검출용 값이 명시됌 

유무선 통신 매체 
- 트위스티드 페어 케이블 : 유선
- WIFI, 전파 : 무선 

#### 허브 (Hub)
- **역할**: 물리 계층의 대표적인 네트워크 장비로, 여러 호스트를 연결합니다. 
- **특징**:
  - **반이중 통신**: 동시에 송신과 수신이 불가능합니다. 한 쪽이 송신할 때 다른 쪽은 수신만 가능합니다.
  - **브로드캐스트 방식**: 수신된 신호를 모든 포트로 전송합니다.
  - **콜리전 도메인**: 모든 호스트가 충돌 영역에 포함되어, 충돌이 빈번하게 발생할 수 있습니다.

#### 스위치 (Switch)
- **역할**: 데이터 링크 계층의 대표적인 네트워크 장비로, 허브의 한계를 보완합니다.
- **특징**:
  - **전이중 통신**: 동시에 송신과 수신이 가능하여 효율성이 높습니다.
  - **유니캐스트 방식**: 신호를 특정 목적지 포트로만 전송합니다.
  - **MAC 주소 학습**: 각 포트에 연결된 호스트의 MAC 주소를 학습하고, 이를 기반으로 신호를 올바른 포트로 전송합니다. 이를 위해 **MAC 주소 테이블**을 사용합니다.
  - **콜리전 도메인 감소**: 각 포트가 별도의 콜리전 도메인을 가지므로 충돌이 줄어듭니다.
  - **VLAN 지원**: 하나의 물리적 네트워크를 여러 개의 논리적 네트워크로 나누어 관리할 수 있습니다.

#### 주요 차이점
- **통신 방식**: 허브는 반이중 통신만 지원하지만, 스위치는 전이중 통신을 지원합니다.
- **신호 전송**: 허브는 신호를 모든 포트로 보내지만, 스위치는 특정 포트로만 신호를 보냅니다.
- **충돌**: 허브는 충돌이 잦으나, 스위치는 충돌을 줄이는 구조입니다.
- **네트워크 세분화**: 스위치는 VLAN을 통해 네트워크를 세분화할 수 있습니다.

#### 문제 
Q. 이더넷 프레임의 각 구성 요소에 대한 설명 중 틀린 것을 고르시오. 

1. 프리앰블: 송수신지 동기화를 위해 사용되는 8바이트 정보로, 현재의 이더넷 프레임이 수신되고 있다는 사실을 알림.   
2. 송수신지 MAC 주소: 프레임을 주고받는 호스트의 물리적 주소를 나타내며, 네트워크에서 가장 중요한 정보 중 하나임. 
3. 타입/길이: 프레임의 타입을 나타내며, 데이터의 최대 크기를 초과할 수 있음. 
4. 데이터: 페이로드로, 실제 전송되는 데이터를 포함하며, 데이터의 최대 크기가 정해져 있음.
5. FCS: 프레임의 트레일러 부분으로, CRC 값을 사용하여 프레임의 오류 여부를 확인함.

<details>

<summary>답</summary>

3. 타입/길이: 프레임의 타입을 나타내며, 데이터의 최대 크기를 초과할 수 있음.

</details>

### 3. 네트워크 계층 - IP

#### 주소 지정 (Addressing)
- **IP 주소**:
  - 네트워크 간 통신에서 호스트를 식별하기 위해 사용됩니다.
  - IPv4는 32비트 주소 체계를 사용하여 0~255 범위의 10진수 4개로 구성됩니다.
  - IPv6는 128비트 주소 체계를 사용합니다.

- **IP 패킷 헤더**:
  - 주요 필드에는 버전, 헤더 길이, 서비스 유형, 패킷 길이, 식별자, 플래그, 단편화 오프셋, TTL, 프로토콜, 체크섬, 송신지 IP 주소, 수신지 IP 주소 등이 포함됩니다.

#### 포트 (Port)
- **포트 번호**:
  - 16비트로 표현되며, 총 65536개의 포트 번호가 있습니다.
  - 0번부터 1023번까지는 잘 알려진 포트(well known ports).
  - 1024번부터 49151번까지는 등록된 포트(registered ports).
  - 49152번부터 65535번까지는 동적 포트(dynamic ports).

- **포트의 역할**:
  - 포트 번호를 통해 특정 호스트가 실행하는 특정 프로세스를 식별할 수 있습니다.
  - IP 주소와 포트 번호를 결합하여 'IP 주소:포트 번호' 형식으로 표기합니다.

#### 주요 포트 번호와 용도
- **잘 알려진 포트**:
  - FTP: 20, 21
  - SSH: 22
  - TELNET: 23
  - DNS: 53
  - DHCP: 67, 68
  - HTTP: 80
  - HTTPS: 443

- **등록된 포트**:
  - OpenVPN: 1194
  - Microsoft SQL Server: 1433
  - MySQL: 3306
  - Redis: 6379
  - HTTP 대체: 8080

#### NAT와 NAPT
- **NAT (Network Address Translation)**:
  - 공인 IP 주소와 사설 IP 주소 간의 변환을 담당.
  - 대부분의 라우터와 공유기에 내장.

- **NAPT (Network Address Port Translation)**:
  - IP 주소와 포트 번호를 함께 변환하여 여러 사설 IP 주소가 하나의 공인 IP 주소를 공유할 수 있게 함.
  - 포트 번호를 사용해 내부 호스트를 구분하여 공인 IP 주소 수의 부족 문제를 해결.

#### 기타 개념
- **IP 주소 클래스**:
  - A 클래스: 대규모 네트워크에 사용.
  - B 클래스: 중규모 네트워크에 사용.
  - C 클래스: 소규모 네트워크에 사용.
  - D 클래스: 멀티캐스트용.
  - E 클래스: 연구용.

- **특수한 IP 주소**:
  - 루프백 주소 (127.0.0.0 ~ 127.255.255.255): 자기 자신을 가리킴.
  - 사설 IP 주소:
    - 10.0.0.0 ~ 10.255.255.255
    - 172.16.0.0 ~ 172.31.255.255
    - 192.168.0.0 ~ 192.168.255.255

### 문제

다음 중 네트워크 주소 지정과 포트에 대한 설명으로 옳지 않은 것을 고르시오.

a. IPv4 주소는 32비트 주소 체계를 사용하며, 0~255 범위의 10진수 4개로 구성됩니다.
b. IPv6 주소는 128비트 주소 체계를 사용합니다.
c. 포트 번호는 16비트로 표현되며, 총 65536개의 포트 번호가 있습니다.
d. 0번부터 1023번까지의 포트 번호는 동적 포트(dynamic ports)로 불립니다.
e. NAT는 공인 IP 주소와 사설 IP 주소 간의 변환을 담당합니다.

<details>

<summary> 정답 </summary>

d. 0번부터 1023번까지의 포트 번호는 동적 포트(dynamic ports)로 불립니다.

- 0번부터 1023번까지의 포트 번호는 잘 알려진 포트(well known ports)로 불립니다.

</details>

### 전송 계층 TCP와 UDP 

TCP와 UDP는 전송 계층에서 중요한 두 가지 프로토콜로, 서로 다른 방식으로 데이터를 전송하고 관리합니다.

#### 1. TCP (Transmission Control Protocol)
TCP는 신뢰성 있는 연결을 기반으로 데이터를 전송합니다. 데이터를 송수신할 때, 패킷이 손실되지 않고 순서대로 도착하는지 확인하는 과정을 거칩니다. TCP의 주요 특징 중 하나는 '3-way Handshake'로, 송신자와 수신자가 연결을 설정할 때 세 단계의 절차를 거쳐 안정적인 통신을 보장합니다. 또한, TCP는 흐름 제어 및 혼잡 제어 기능을 갖추고 있어 네트워크 상황에 맞춰 속도를 조절합니다.

#### 2. UDP (User Datagram Protocol)
UDP는 비연결형 프로토콜로, TCP와 달리 데이터를 전송할 때 신뢰성을 보장하지 않습니다. 대신 빠른 전송이 가능하며, 실시간 응용 프로그램에서 주로 사용됩니다. UDP는 오류 검사를 제공하지만 패킷의 순서 보장이나 재전송 기능이 없습니다. 이러한 특성으로 인해 영상 스트리밍이나 게임 등 실시간 서비스에서 많이 활용됩니다.

#### 3. TCP 상태 관리
TCP는 연결 설정부터 해제까지 다양한 상태를 거치며 데이터를 관리합니다. 이 중 중요한 상태는 다음과 같습니다:
- **ESTABLISHED**: 연결이 성공적으로 설정되고, 데이터 전송이 가능한 상태.
- **FIN-WAIT-1/FIN-WAIT-2**: 송신자가 연결을 종료하기 위해 FIN 패킷을 보내고 응답을 기다리는 상태.
- **TIME-WAIT**: 연결 종료 후 일정 시간을 대기하는 상태로, 패킷의 유실을 방지하기 위해 사용됩니다.
- **CLOSED**: 연결이 완전히 종료된 상태.

TCP 연결 종료는 FIN 패킷을 주고받으며 이루어지는데, 클라이언트와 서버가 모두 FIN 패킷을 송수신한 후 연결이 종료됩니다. 이 과정에서 특정 시간 동안 재전송이 필요한 상황을 고려하여 `TIME-WAIT` 상태에서 대기하게 됩니다 .

사설 IP와 공인 IP는 네트워크에서 사용하는 IP 주소의 두 가지 유형으로, 그 역할과 사용 용도가 다릅니다.

##### 1. **사설 IP (Private IP)**:
   - **사용 목적**: 내부 네트워크(예: 가정, 회사)에서만 사용되는 IP 주소입니다.
   - **특징**: 라우터나 스위치 등의 네트워크 장비가 내부 네트워크 장치들에 할당하는 IP입니다. 인터넷 상에서는 직접 통신할 수 없으며, 내부 네트워크 내에서만 통신이 가능합니다.
   - **주소 범위**: 사설 IP는 특정한 범위 내에서 사용됩니다. 이 범위는 **RFC 1918**에 의해 정의되어 있으며, 다음과 같은 IP 대역을 포함합니다:
     - 10.0.0.0 ~ 10.255.255.255
     - 172.16.0.0 ~ 172.31.255.255
     - 192.168.0.0 ~ 192.168.255.255
   - **예시**: 192.168.1.1 (많은 가정용 라우터에서 기본적으로 사용하는 IP)

##### 2. **공인 IP (Public IP)**:
   - **사용 목적**: 전 세계 어디에서든 인터넷을 통해 접근 가능한 고유한 IP 주소입니다.
   - **특징**: 공인 IP는 ISP(인터넷 서비스 제공자)로부터 할당받은 주소로, 인터넷에 연결된 장치들이 서로 직접 통신할 수 있도록 합니다. 공인 IP는 전 세계에서 유일해야 하며, 중복되지 않도록 관리됩니다.
   - **주소 범위**: 사설 IP 범위를 제외한 나머지 모든 IP 주소들이 공인 IP에 해당합니다.
   - **예시**: 8.8.8.8 (Google의 공용 DNS 서버 IP)

### 차이점 요약:
- **네트워크 범위**: 사설 IP는 내부 네트워크에서만 사용되고, 공인 IP는 인터넷 상에서 사용됩니다.
- **접근 가능성**: 사설 IP는 외부에서 직접 접근할 수 없고, 공인 IP는 인터넷을 통해 전 세계에서 접근 가능합니다.
- **할당 방식**: 사설 IP는 네트워크 장치가 내부적으로 할당하며, 공인 IP는 ISP로부터 할당받습니다.

### 문제
TCP 연결 수립 과정에서 사용하는 **3-way Handshake**는 어떤 세 단계로 이루어지나요?

![alt text](/assets/img/TCP-handshake.png)

### 응용계층 - HTTP의 기초 

#### 1. **DNS와 URI/URL**
- **DNS (Domain Name System)**: 도메인 네임을 IP 주소로 변환해주는 시스템입니다. 도메인 네임은 사람이 이해하기 쉬운 형태의 주소이며, 네트워크 상의 서버 간 통신을 위해 IP 주소로 변환됩니다. DNS 서버는 이러한 변환 작업을 담당하며, 사용자는 이를 통해 복잡한 IP 주소 대신 간단한 도메인 이름을 사용할 수 있습니다.
- **URI와 URL**: URI는 리소스를 식별하는 방식의 총칭이며, URL은 해당 리소스의 위치를 나타내는 방식입니다. URI와 URL은 웹에서 자원을 찾기 위한 중요한 개념입니다.

#### HTTP의 기초 - 인터넷의 기반 프로토콜

HTTP(HyperText Transfer Protocol)는 오늘날 웹 상에서 데이터를 주고받기 위한 가장 중요한 프로토콜입니다. 이 프로토콜은 클라이언트와 서버가 데이터를 주고받는 데 사용되며, 우리가 브라우저에서 URL을 입력할 때 시작되는 요청-응답의 기반을 제공합니다.

#### **HTTP의 주요 특징**

- **요청-응답 기반**: HTTP는 클라이언트가 요청을 보내고 서버가 그 요청에 응답하는 구조로 동작합니다. 예를 들어, 브라우저에서 URL을 입력하면 이는 서버로 요청을 보내는 것이며, 서버는 해당 웹 페이지를 클라이언트에 응답으로 보냅니다.
  
- **스테이트리스**: HTTP는 상태를 유지하지 않습니다. 즉, 각 요청은 독립적으로 처리되며, 이전 요청의 정보를 유지하지 않습니다. 이를 보완하기 위해 쿠키나 세션 같은 기술이 사용됩니다.
  
- **미디어 독립성**: HTTP는 전송하는 데이터의 형식에 제한이 없습니다. 텍스트, 이미지, 동영상 등 다양한 형식의 데이터를 전송할 수 있습니다.

- **지속 연결 지원**: HTTP 1.1 버전부터는 '지속 연결'이 지원되어, 여러 요청을 한 번의 연결에서 처리할 수 있어 성능을 향상시킵니다.

#### **HTTP 메시지 구조**
HTTP는 요청과 응답 메시지로 구분되며, 메시지의 구조는 헤더와 본문으로 나뉩니다.

- **헤더**: 요청이나 응답에 대한 메타데이터가 포함됩니다. 예를 들어, 요청하는 리소스의 위치(URL), 클라이언트 정보, 서버 정보 등이 있습니다.
  
- **본문**: 실제로 전송되는 데이터가 포함됩니다. HTML 문서, 이미지, JSON 데이터 등 다양한 형식이 본문에 담길 수 있습니다.

#### **HTTP의 버전 발전**
HTTP는 시간이 지나면서 발전해왔으며, 현재 많이 사용되는 버전은 HTTP/1.1, HTTP/2, HTTP/3입니다. 특히 HTTP/2와 HTTP/3은 성능 향상과 보안성을 강화하는 방향으로 발전되었습니다.


### 문제
**HTTP가 상태를 유지하지 않기 때문에 발생하는 문제를 해결하기 위한 대표적인 기술은 무엇일까요?**

**답변**: 쿠키

### 응용계층 - HTTP의 응용 

1. **쿠키 (Cookies)**: HTTP는 스테이트리스(stateless) 프로토콜로, 요청마다 독립적인 메시지로 처리됩니다. 하지만, 사용자 상태를 기억해야 하는 경우 쿠키를 사용하여 클라이언트 상태를 유지할 수 있습니다. 쿠키는 서버가 생성해 클라이언트에 저장되며, 이후 동일한 서버에 요청할 때 쿠키 정보를 함께 전송하여 사용자 정보를 관리합니다.

2. **캐시 (Cache)**: 캐시는 서버로부터 받은 데이터를 클라이언트 측에서 저장해 두고, 필요할 때 서버로부터 데이터를 재전송받는 것을 최소화하는 기술입니다. 이는 네트워크 성능을 최적화하고, 서버 부하를 줄이는 데 기여합니다.

3. **콘텐츠 협상 (Content Negotiation)**: 클라이언트와 서버 간의 콘텐츠 타입 협상으로, 클라이언트는 서버에 요청할 때 자신이 수용할 수 있는 콘텐츠 타입을 명시할 수 있습니다. 서버는 그에 맞는 형식으로 응답을 전송하는 방식입니다.

4. **인증 (Authentication)**: HTTP는 기본적인 인증 방식을 제공하며, 인증 정보를 통해 서버가 요청을 처리할 수 있습니다. 이는 보안과 관련된 부분에서 중요한 역할을 합니다.

5. **HTTPS와 보안 (SSL/TLS)**: HTTP의 보안 버전인 HTTPS는 SSL/TLS 프로토콜을 통해 안전한 데이터 송수신을 보장합니다. 이는 암호화된 채널을 통해 데이터를 전송함으로써 중간에서의 데이터 도청이나 변조를 방지하는 데 사용됩니다.

이 모든 기술은 HTTP의 기본 구조를 기반으로, 웹 응용 프로그램의 성능 및 보안성을 높이는 데 사용됩니다.


#### 문제 
HTTPS는 무엇이며, 어떻게 보안을 제공하나요?

<details>

<summary> 정답 </summary>

HTTPS는 HTTP의 보안 버전으로, SSL/TLS 프로토콜을 통해 데이터 전송을 암호화하여 클라이언트와 서버 간의 통신을 보호합니다. 이를 통해 데이터가 전송 중에 도청되거나 변조되지 않도록 보장합니다. HTTPS는 SSL/TLS 인증서를 통해 서버 신원을 확인하고, 세션 암호화를 수행하여 안전한 통신 환경을 제공합니다.

</details>

### 프록시와 안정적인 트래픽

이 부분에서는 네트워크의 안정성과 가용성을 보장하기 위해 사용되는 기술과 프록시 서버의 역할을 설명합니다. 아래는 이 주제에 대한 요약입니다:

#### 1. **프록시(Proxy)**
   - **포워드 프록시 (Forward Proxy)**: 클라이언트가 특정 서버에 직접 연결하지 않고 프록시 서버를 통해 간접적으로 요청을 처리하는 방식입니다. 이 방식은 클라이언트와 서버 사이에 프록시 서버가 위치해 클라이언트의 요청을 대신 처리하고, 서버에서 받은 응답을 다시 클라이언트에게 전달합니다. 주로 웹 필터링, 캐시 저장, 보안 등 클라이언트 쪽에 이점을 제공합니다.
   
   - **리버스 프록시 (Reverse Proxy)**: 서버 앞에 위치하여 클라이언트의 요청을 받아 오리진 서버(origin server)로 전달하는 역할을 합니다. 서버의 부하를 줄이기 위한 로드 밸런싱, 보안 및 캐시 기능을 통해 서버의 가용성과 성능을 향상시킵니다.

#### 2. **고가용성 (High Availability)**
   고가용성은 시스템이 장애가 발생해도 지속적으로 서비스를 제공할 수 있는 능력을 의미합니다. 이를 위해 주로 **로드 밸런싱**과 **스케일링** 기술이 사용됩니다.

   - **로드 밸런싱 (Load Balancing)**: 여러 서버에 걸쳐 클라이언트 요청을 분산시켜 서버의 부하를 균등하게 분배하는 기술입니다. 로드 밸런싱을 통해 하나의 서버에 과부하가 걸리는 것을 방지하고, 시스템의 전체 가용성을 높입니다.
   
   - **스케일링 (Scaling)**: 서버의 성능을 향상시키기 위한 방법으로, 두 가지 형태가 있습니다.
     - **스케일 업 (Scale-Up)**: 기존 서버의 성능을 향상시키는 방식.
     - **스케일 아웃 (Scale-Out)**: 여러 대의 서버를 추가하여 성능을 확장하는 방식.

#### 3. **Nginx와 로드 밸런싱**
   Nginx는 리버스 프록시 역할을 수행하며, 로드 밸런싱 기능을 제공하는 대표적인 웹 서버 소프트웨어입니다. 이를 통해 다양한 클라이언트 요청을 다수의 서버에 분산시키고, 트래픽을 효과적으로 관리하여 서버 가용성을 극대화할 수 있습니다【8:1†source】【8:2†source】. 


#### 문제
로드 밸런싱의 역할과 이점은 무엇인가요?

<details>

<summary> 정답 </summary>

로드 밸런싱은 클라이언트 요청을 여러 서버에 분산시켜 서버 부하를 고르게 나누어 주는 역할을 합니다. 이를 통해 서버 한 대에 과부하가 걸리는 상황을 방지하고, 서비스의 가용성과 안정성을 높이는 이점을 제공합니다. 또한, 서버 장애 발생 시 다른 서버로 트래픽을 분산시켜 서비스가 중단되지 않도록 합니다.
</details>

웹 브라우저 상에 ‘https://www.google.com’을 입력해 웹사이트가 뜨기까지의 과정을
설명해 보세요.


<details>

<summary> 정답 </summary>

가장먼저로컬DNS서버에‘www.google.com’에해당하는IP주소가캐시되어있는지를 확인합니다. 만약 로컬 DNS 서버가 해당 IP 주소를 저장하고 있다면 해당 IP 주소를 응답하 고, 저장하고 있지 않다면 루트 DNS 서버부터 ‘com’ 최상위 도메인(TLD) 서버, google 도 메인 서버 등 도메인 네임을 순차적으로 질의하여 IP 주소를 얻어 냅니다.
그리고 클라이언트가 IP 주소를 알게 되면 해당 IP 주소로 TCP 연결을 설정합니다. 이 과정 에서 TCP의 쓰리 웨이 핸드셰이크가 수행됩니다. 클라이언트가 서버에 SYN 패킷을 보내고, 서버가 SYN-ACK 패킷으로 응답하면 다시 클라이언트가 ACK 패킷을 보내 연결을 확립합 니다.
TCP 연결이 설정되면 HTTP 요청을 보냅니다. HTTPS의 경우 SSL/TLS 핸드셰이크가 추가 로 수행되어 보안 연결을 설정합니다. 이후 클라이언트는 GET 요청을 통해 ‘www.google. com’의 리소스를 요청하고, 요청을 받은 서버는 필요한 데이터를 준비하여 HTTP 응답으로 보냅니다. 이 HTTP 응답에는 요청한 웹 페이지의 HTML 문서가 포함되어 있습니다.

</details>

## chapter 6 데이터베이스 

- 데이터베이스 기본 개념: 데이터베이스는 데이터를 체계적으로 저장하는 시스템이며, 이를 관리하는 시스템이 DBMS (데이터베이스 관리 시스템)입니다. DBMS는 데이터의 구조화, 접근 제어, 효율적인 저장을 지원합니다.
- 파일 시스템과의 차이점: 데이터베이스는 다중 사용자 접근, 빠른 검색, 보안 기능을 제공하며, 이로 인해 대규모 데이터나 다수의 사용자가 필요한 환경에서 더 효율적입니다.

#### 관계형 데이터베이스 시스템(RDBMS)
- 테이블, 필드, 레코드: RDBMS는 테이블을 이용해 데이터를 구조화하고, 테이블의 필드(열)와 레코드(행)로 데이터를 관리합니다.
- 테이블 간 관계: 테이블 간 관계는 주 키(Primary Key)와 외래 키(Foreign Key)를 통해 연결되며, 이를 통해 복잡한 데이터 검색이 가능합니다.
- 무결성 제약 조건: 무결성 제약 조건은 데이터의 일관성과 정확성을 보장하여 중복 데이터나 잘못된 참조를 방지합니다.

#### SQL 
- 데이터 정의 언어(DDL): CREATE, ALTER, DROP, TRUNCATE 등의 명령어는 데이터베이스 구조를 정의하거나 수정하는 데 사용됩니다.
- 데이터 조작 언어(DML): SELECT, INSERT, UPDATE, DELETE와 같은 명령어는 테이블 내 데이터 조작을 수행합니다.
- 트랜잭션 제어 언어(TCL): COMMIT, ROLLBACK, SAVEPOINT는 트랜잭션을 제어하며, 데이터베이스 작업에서 원자성과 격리성을 유지하도록 도와줍니다.

#### 문제


<details>

<summary> Q1. 파일 시스템 대신 데이터베이스를 사용하는 이유는 무엇인가요? </summary>

데이터베이스는 파일 시스템에 비해 다중 사용자 접근, 빠른 검색, 보안 기능이 뛰어나 대규모 데이터 환경에 적합합니다.

</details>



<details>

<summary> Q2. 테이블에서 주 키(Primary Key)의 역할은 무엇인가요? </summary>

주 키는 테이블 내에서 각 레코드를 고유하게 식별하는 역할을 하며, 데이터 중복을 방지하고 테이블 간의 관계 설정을 가능하게 합니다.

</details>



<details>

<summary> Q3. COMMIT과 ROLLBACK 명령어의 차이점을 설명하세요. </summary>

 COMMIT은 트랜잭션 동안의 모든 변경 사항을 영구 저장하고, ROLLBACK은 오류 발생 시 데이터베이스를 이전 상태로 되돌립니다.
 
</details>


### 효율적인 SQL 쿼리
- **서브쿼리**: SQL의 서브쿼리(또는 중첩 쿼리)는 하나의 쿼리 내에 다른 쿼리를 포함하는 것으로, `SELECT`, `DELETE` 등의 문장에서 복잡한 필터링을 수행하는 데 유용합니다.
- **조인 (JOIN)**: `INNER JOIN`, `OUTER JOIN`, `FULL OUTER JOIN`과 같은 SQL 조인은 관련된 컬럼을 기준으로 여러 테이블의 행을 결합하는 방식입니다. 여러 테이블에 걸친 데이터 조회 시 필수적인 기능입니다.
- **뷰 (View)**: 뷰는 `SELECT` 쿼리의 결과를 기반으로 한 가상의 테이블로, 복잡한 쿼리를 단순화하고 재사용성을 높여줍니다.
- **인덱스**: 인덱스는 데이터를 빠르게 검색할 수 있도록 하여 쿼리 성능을 향상시킵니다. 적절한 인덱싱을 통해 데이터 접근 속도를 크게 높일 수 있습니다.

### 데이터베이스 설계 원칙
- **ER 다이어그램**: 엔터티-관계(ER) 다이어그램은 데이터베이스의 스키마와 테이블 간의 관계를 시각화하는 데 사용됩니다.
- **정규화**: 데이터 중복을 최소화하기 위한 데이터 구성 과정입니다. 제1정규형(1NF), 제2정규형(2NF), 제3정규형(3NF), 보이스-코드 정규형(BCNF) 등의 단계로 구성됩니다.

### NoSQL 데이터베이스
- **NoSQL 데이터베이스 종류**: 키-값 저장소, 문서 데이터베이스, 그래프 데이터베이스, 컬럼 패밀리 저장소 등이 포함됩니다.
- **RDBMS와의 비교**: NoSQL 데이터베이스는 비정형 또는 반정형 데이터를 유연하게 처리할 수 있어, 실시간 데이터 처리나 대규모 분산 시스템과 같은 특정 용도에 적합합니다.

이 부분에서는 SQL 최적화 기법과 관계형 및 NoSQL 데이터베이스의 핵심 개념을 심도 있게 설명하고 있습니다【10:1†source】【10:6†source】【10:7†source】.


#### 문제
Q. 인덱스는 무엇인가요? 인덱스가 오히려 성능을 악화시키는 사례도 있습니다. 이러한 성능 악화는 어떤 상황에서 발
생하는지, 그래서 인덱스를 언제, 어떻게 사용해야 하는지에 대해 설명해 보세요.

<details>

<summary> 답 </summary>

 인덱스는 특정 테이블 열에 대한 자료구조로, 검색 속도를 향상시키기 위해 사용합니다. 책의
찾아보기와 유사한 개념으로, 인덱스를 통해 원하는 데이터를 빠르게 조회할 수 있습니다. 인
덱스를 생성하면 해당 테이블의 열 값들이 정렬된 형태로 저장되므로 테이블 전체를 탐색하지
않고도 빠르게 데이터를 찾을 수 있어 검색 성능이 향상됩니다.    
    
인덱스를 사용하면 SELECT 연산의 성능은 향상시킬 수 있지만, INSERT나 UPDATE,
DELETE 연산에서는 성능을 저하시킬 수 있습니다. 새로운 데이터를 삽입하거나 기존 데이터
를 수정/삭제하는 경우에는 인덱스도 함께 갱신해야 하기 때문입니다. 따라서 인덱스는 데이터
가 많고 조회가 빈번한 테이블에 사용하며, 중복 데이터가 많지 않은 열이나 JOIN, WHERE,
ORDER BY에서 자주 참조되는 열에 생성하는 것이 효율적입니다.    
    
-> 카디널리티가 늪은 열 (유니크한 데이터가 많을수록 효과있음) ex 주민번호 등 
안좋은 인덱스는 성별 같이 카디널리티가 낮은 데이터. 불리언 타입 등 

</details>

Q. 파티셔닝과 데이터베이스 샤딩이 무엇인지 설명해 보세요. 둘의 차이는 무엇인가요? 

<details>

<summary> 답 </summary>

안정적이고 확장성 높은 데이터베이스 레코드 관리를 위해 테이블을 물리적으로 분할하여 레코
드를 저장하는 기술을 파티셔닝이라고 합니다. 

데이터베이스 샤딩은 샤드라는 단위로 여러 데이터베이스 서버에 걸쳐 테이블을 분할하여
저장하는 기술을 의미합니다. 여러 서버에 분산되어 저장되는 특성 덕분에 데이터베이스에
대한 부하 분산 효과를 얻을 수 있습니다.

파티셔닝은 한 DB에서 테이블을 어떤 기준(범위, 조건)에 따라 분할하는 것, 샤딩은 데이터베이스로 분할 

</details>
