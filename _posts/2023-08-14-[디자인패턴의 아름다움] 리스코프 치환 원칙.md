---
layout: post
categories: T.I.L 공부
---

## 리스코프 치환의 원칙 
> 만약 S가 T의 하위 유형인 경우, T 유형의 객체는 프로그램을 중단하지 않고도 S 유형의 객체로 대체될 수 있다. -바바라 리스코프-    
>    
> 기본 클래스에서 참조 포인터를 사용하는 함수는 특별히 인지하지 않고도 파생 클래스의 객체를 사용할 수 있어야 한다. - 로버트 마틴 - 

하위 유형 또는 파생 클래스의 객체는 프로그램 내에서 상위 클래스가 나타나는 모든 상황에서 **대체 가능**하며, 프로그램이 원래 가지는 논리적인 동작이 변경되지 않으며 정확성도 유지된다. 

리스코프 치환 원칙과 다형성은 보기에는 비슷하지만, 실제로는 완전히 다른 의미를 담고 있다. 다형성은 코드를 **구현하는 방식**에 해당하지만, 리스코프 치환 원칙은 상속관계에서 하위 클래스의 설계 방식을 설명하는 **설계 원칙**에 해당한다. 상위 클래스를 대체할 때 프로그램의 원래 **논리적 동작이 변경되지 않고 프로그램의 정확성이 손상되지 않도록 해야한다**는 원칙이다. 

리스코프 원칙에는 좀 더 이해하기 쉬운 설명 방식이 있는데, 바로 **계약에 따른 설계**라는 표현이다. 하위 클래스를 설계할 떄는 상위 클래스의 동작 규칙을 따라야 한다. 상위 클래스는 함수의 동작 규칙을 정의하고 하위 클래스는 함수의 내부 구현 논리를 변경할 수 있지만 함수의 원래 동작 규칙은 변경할 수 없다. 동작 규칙에는 함수가 구현하기 위해 선언한 것, 입력, 출력, 예외에 대한 규칙, 주석에 나열된 모든 특수 사례 설명이 포함된다. 

하위 클래스의 설계와 구현이 리스코프 치환 원칙을 위반하는지 여부를 판단하기 위한 방법으로 상위 클래스의 단위 테스트를 총해 하위 클래스의 코드르 확인하는 방법도 있다. 만약 일부 단위 테스트가 실행되지 않으면 하위 클래스의 설계와 구현이 상위 클래스의 계약을 완전히 준수 하지 않고 하위 클래스가 리스코프 치환 원칙을 위반할 수 있음을 의미한다. 

### 생각해보기
리스코프 치환 원리의 중요성은 무엇인지 생각해보자. 

-> 일관성, 목적? 설계가 구현시 변경되어서는 안된다. 
