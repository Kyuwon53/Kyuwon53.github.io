---
layout: post
categories: 공부 
---

# 3_ 사용자 및 권한 

> 역할과 계정은 내외부적으로 동일한 객체라고 했는데, 왜 MySQL 서버에서는 굳이 CREATE ROLE 명령과 CREATE USER 명령을 구분해서 지원할까? 

- 데이터베이스 관리의 직무를 분리할 수 있게 하여 보안을 강화하는 용도로 사용될 수 있게 하기 위해서 

<br>

# 4_ 아키텍처

## MySQL 서버 

### MySQL 엔진 : DBMS의 두뇌에 해당하는 처리를 수행
    - 클라이언트로부터의 접속 및 쿼리 요청을 처리하는 커넥션 핸들러와 SQL 파서 및 전처리기, 쿼리의 최적화된 실행을 위한 옵티마이저가 중심
    - 요청된 SQL 문장을 분석하거나 최적화    

### MySQL 스토리지 엔진 : 손발 역할      
    - 핸들러 API를 만족하면 누구든지 스토리지 엔진을 구현해서 MySQL 서버에 추가해서 사용 가능 
    - 실제 데이터를 디스크 스토리지에 저장하거나 디스크 스토리지로부터 데이터를 읽어옴 
    - 각 스토리지 엔진은 성능 향상을 위해 키 캐시나 InnoDB 버퍼 풀(InnoDB 스토리지 엔진)과 같은 기능을 내장하고 있음

MySQL 서버는 프로세스 기반이 아니라 스레드 기반으로 작동
    - 크게 포그라운드 스레드와 백그라운드 스레드로 구분 

<br>

## MySQL 스레딩 구조

### 포그라운드 스레드(클라이언트 스레드) 
- 최소한 MySQL 서버에 접속된 클라이언트의 수만큼 존재하며, 주로 각 클라이언트 사용자가 요청하는 쿼리 문장을 처리 
- 클라이언트 사용자가 작업을 마치고 커넥션을 종료하면 해당 커넥션을 담당하던 스레드는 다시 스레드 캐시로 되돌아감
- 스레드 캐시에 일정 개수 이상의 대기 중인 스레드가 있으면 스레드 캐시에 넣지 않고 스레드를 종료시켜 일정 개수의 스레드만 스레드 캐시에 존재
    - 스레드 캐시에 유지할 수 있는 최대 스레드 개수는 시스템 변수로 설정 
- MySQL의 데이터 버퍼나 캐시로부터 데이터를 가져옴 
- 버퍼나 캐시에 없는 경우 직접 디스크의 데이터나 인덱스 파일로부터 데이터를 읽어와 작업을 처리 
    - MyISAM 테이블은 디스크 쓰기 작업까지 포그라운드 스레드가 처리 
    - InnoDB 테이블은 데이터 버퍼나 캐시까지만 포그라운드 스레드가 처리, 나머지 버퍼로부터 디스크까지 기록하는 작업은 백그라운드 스레드가 처리 

### 백그라운드 스레드
InnoDB는 여러 가지 작업이 백그라운드로 처리된다. 
- 인서트 버퍼를 병합하는 스레드
- **로그를 디스크로 기록하는 스레드**
- **InnoDB 버퍼 풀의 데이터를 디스크에 기록하는 스레드**
- 데이터를 버퍼로 읽어 오는 스레드
- 잠금이나 데드락을 모니터링하는 스레드 

데이터를 읽는 작업은 주로 클라이언트 스레드에서 처리되기 때문에 읽기 스레드는 많이 설정할 필요가 없다. 
쓰기 스레드는 아주 많은 작업을 백그라운드로 처리하기 때문에 일반적인 내장 디스크를 사용할 때는 2~4, DAS나 SAN과 같은 스토리지를 사용할 때는 디스크를 최적으로 사용할 수 있을 만큼 충분히 설정하는 것이 좋음 

사용자의 요청을 처리하는 도중 데이터의 쓰기 작업은 지연(버퍼링)되어 처리될 수 있지만 데이터의 읽기 작업은 절대 지연될 수 없다. 
대부분 쓰기 작업을 버퍼링해서 일괄 처리하는 기능이 탑재돼 있다. (하지만 MyISAM은 사용자 스레드가 쓰기 작업까지 함께 처리되도록 설계돼 있다.)

## 메모리 할당 및 사용 구조 

### 글로벌 메모리 영역
- 모든 메모리 공간은 MySQL 서버가 시작되면서 운영체제로부터 할당됨
- 클라이언트 스레드의 수와 무관하게 하나의 메모리 공간만 할당됨
    - 필요에 따라 2개 이산의 메모리 공간을 할당받을 수도 있지만 클라이언트의 스레드 수와는 무관
    - 생성된 글로벌 영역이 N개라 하더라도 모든 스레드에 의해 공유됨 

- 대표적 글로벌 메모리 영역 
    - 테이블 캐시
    - InnoDB 버퍼 풀
    - InnoDB 어댑티브 해시 인덱스
    - InnoDB 리두 로그 버퍼 

### 로컬 메모리 영역 
- 세션 메모리 영역
- 클라이언트 스레드가 쿼리를 처리하는 데 사용하는 메모리 영역
-  로컬 메모리는 각 클라이언트 스레드별로 독립적으로 할당되며 절대 공유되어 사용되지 않는다
-  각 쿼리의 용도별로 필요할 때만 공간이 할당되고 필요하지 않은 경우에는 MySQL이 메모리 공간을 할당조차도 하지 않을 수도 있다. 
- 로컬 메모리 공간은 커넥션이 열려 있는 동안 계속 할당된 상태로 남아 있는 공간도 있고(커넥션 버퍼나 결과 버퍼) 그렇지 않고 쿼리를 실행하는 순간에만 할당했다가 다시 해제하는 공간(소트 버퍼나 조인 버퍼)도 있다. 
